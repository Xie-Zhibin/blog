# 算法分析
> 算法是为求解一个问题需要遵循的、被清楚指定的简单指令的集合。对于一个问题，一旦某种算法给定并且以某种方式被确定是正确的，那么重要的一步就是确定算法将需要多少诸如时间或空间等资源的问题。
> 在分析一个实际问题时，答案取决于许多因素，比如所使用的计算机性能、被处理的数据的性质和完成任务所使用的程序（实现了某种算法），这些因素都会产生大量需要分析的信息。
> 但为这些基础问题给出实质性的答案有时其实非常简单，这个过程的基础是科学方法:
> 	* 细致地观察真实世界的特点，通常还要有精确的测量;
> 	* 根据观察结果提出假设模型;
> 	* 根据模型预测未来的事件;
> 	* 继续观察并核实预测的准确性;
> 	* 如此反复直到确认预测和观察一致。
> 科学方法的一条关键原则是我们所设计的实验必须是可重现的，这样他人也可以自己验证假设的真实性。所有的假设必须是可证伪的，这样我们才能确认某个假设是错误的(并需要修正)。

尽管有许多复杂的因素影响着我们对程序的运行时间的理解，原则上我们仍然可能构造出一个数学模型来描述任意程序的运行时间。Knuth的看法很简单----一个程序运行时间主要和两点有关：
	* 执行每条语句的耗时
	* 执行每条语句的频率
前者取决于计算机、java编译器和操作系统，后者取决于程序本身和输入。如果对于程序的所有部分都知道了这些性质，就可以将它们相乘并将程序中所有指令的成本相加得到总运行时间。

为了简化分析，通常约定不存在特定的时间单位。同时在粗略估计中，并不需要十分具体的数值或函数模型，可以忽略公式中那些非常复杂但幂次较低，且对最终结果的贡献无关紧要的项，并将次数最高的项的系数视为1.

我们一般比较的是相对增长率，有一下几个标记法：
对于T(N)、f(N)
* 大O标记法,T(N) = O(f(N))，表示f(N)是T(N)的上界,即T(N)是在以不快于f(N)的速度增长(小于等于)。
* Ω, T(N) = Ω(f(N))，T(N) 的增长率大于或等于f(N)。
* Θ, T(N) 的增长率与f(N)的相等
* 小o标记法，T(N) 的增长率小于f(N)， 注意大O包括相等的情况。
对于相对增长率，要尽可能地选择最匹配的标记法去表示。
很多时候要确定程序运行时间的上界，即保证程序耗费的时间不会超过这个界限，以保守的估计提供性能保证。

几种典型的增长数量级
```
函数		 名称
1		   常数级别
logN	    对数级别
N		   线性级别
NlogN	   线性对数级别
N^2		 平方级别
N^3		 立方级别
2^N		 指数级别
```

速度缓慢的程序和不正确的程序一样无用。
