# Thinking in Python

> 趁着十一假期，将Python复习了一遍，重新看了一遍《python核心编程》，把原来不太清楚的或者被忽略的一些盲点难点再次理解了一遍，总结如下。

***

#### 1.迭代器和iter()函数
> * 根本上说，迭代器就是一个有next()方法的对象，而不是像序列一样是通过索引来计数的。当自己或者一个循环机制（例如for循环）需要下一项时，调用迭代器的next()方法就可以获得它。条目全部取出后会引发一个StopIteration异常表示迭代完成。
> * 迭代器的限制：不能向后移动，不能回到开始，也不能复制一个迭代器。
> * 对一个对象调用iter()可以得到它的迭代器,如果有两个参数(iter(func, sentinel))，它会反复调用func直到下一个值为sentinel
> * 一般的可迭代器对象有，序列，字典，文件。
> * 迭代器（Iterable） 只是对象每次返回特定成员的一种能力

***

#### 2.函数式编程
##### A.函数（方法）装饰器
> 装饰器实际就是一个返回函数的高阶函数，他们接受函数对象并返回了函数对象。从本质上看，这些特征引入了Spring框架的核心概念AOP(Aspect Oriented Programming, 面向切面编程)。
> 对于无参装饰器，定义如下
> ```
> @deco
> def func():
>     pass
> ```
> 等价于
> ```
> func = deco(func)
> ```
> ----
> 对于有参装饰器，需要编写一个返回修饰器的高阶函数，如
> ```
> @decomaker(deco_args)
> def func():
> 	pass
> ```
> 等价于
> ```
> func = decomaker(deco_args)(func)
> ```
> 这就相当于带有deco_args的decomaker函数执行完成以后返回了一个函数对象，该函数对象即为装饰器。
> 参考廖雪峰的文章：http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819879946007bbf6ad052463ab18034f0254bf355000

----

##### B.偏函数
>与数学意义上的偏函数不同，python中的偏函数主要是把一个函数的某些参数固定（设置默认值），返回一个新的函数，使得更加容易地调用这个新函数。
>python的functools模块的partial()函数提供了相应的功能。
>例如：
>```
>base_two = functools.partial(int, base = 2)  # 等价于：
>base_two(x) == int(x, base = 2)
>```
>注意：警惕关键字, 固定参数总是放在运行时刻参数的左边，比如
>```
>base_two = functools.partial(int, 2)  # 将得到
>base_two(x) == int(2, x)
>```
>这会得到一个错误的结果。

-----

##### C.闭包
> 如果在一个内部函数里，对在外部作用域(但不是在全局作用域)的变量进行引用，那么内部函数就被认为是闭包(closure).
> 闭包在JS中使用得比较多，在Python中相对少见，不过有时候即使用了也没注意到，比如在装饰器中。浅显地说，要形成闭包，首先得有一个嵌套的函数，即函数中定义了另一个函数，闭包则是一个集合，它包括了外部函数的局部变量，这些局部变量在外部函数返回后也继续存在，并能被内部函数引用,不会像普通的局部变量在函数调用结束时便被销毁。
> 闭包的词法变量既不属于全局名称空间也不属于局部名称空间，而属于其他的名称空间，带着“流浪”的作用域。
> 和闭包相关的就是 ```__closure__``` 属性。该属性定义的是一个包含 cell 对象的元组，其中元组中的每一个 cell 对象用来保存作用域中变量的值，如果没有闭包的形成，则该属性值为None。
> 参考这篇文章：https://serholiu.com/python-closures

-----

##### D.生成器
> 从语法上讲，生成器是一个带有yield语句的函数。一个函数或者子程序只返回一次。
> 一个生成器函数的定义很像一个普通的函数，除了当它要生成一个值的时候，使用yield关键字而不是return。
> 调用一个普通的Python函数时，一般是从函数的第一行代码开始执行，结束于return语句、异常或者函数结束（可以看作隐式的返回None）。一旦函数将控制权交还给调用者，就意味着全部结束。函数中做的所有工作以及保存在局部变量中的数据都将丢失。再次调用这个函数时，一切都将从头创建。
> 与迭代器相似，生成器以另外的方式来运作：当到达一个真正的返回或者函数没有更多的值返回（调用next()），一个StopIteration异常就会抛出。
> 当一个生成器函数调用yield，生成器函数的“状态”会被冻结，所有的变量的值会被保留下来，下一行要执行的代码的位置也会被记录，直到再次调用next()。一旦next()再次被调用，生成器函数会从它上次离开的地方开始。

***

#### 3.面向对象编程
##### A. 类
> 类属性包括 数据属性 及 函数属性（方法）。类数据属性是静态的，类似于Java中被static修饰的数据域，与之相对的是实例数据属性。
> 在类中直接定义的数据属性为静态属性，相反的，在类中定义的方法默认为实例方法，除非用@staticmenthod修饰，才能成为静态方法。

-----
##### B.```__del__()```解构器 方法
> 由于Python具有垃圾对象回收机制（引用计数），这个方法要直到该实例对象所有的引用都被清除掉后才会执行。Python中的解构器是在实例释放前提供特殊处理功能的方法。
> 注意：不要忘记首先调用父类的```__del__()```.

-------

##### C.静态方法与类方法
> Python中的静态方法（用@staticmethod修饰）与Java、C++中的一样，不必多说。
> 对于类方法(用@classmethod修饰)，类似实例方法需要一个实例（self）作为第一个参数一样，需要类作为第一个参数，它也是由解释器自动传递给方法的，类不需要特别的命名，类似self，不过通常会使用cls。
> 静态方法和类方法均可以直接通过类来调用，而由于类方法在调用时解释器会自动传递类本身作为第一个参数，可以在一些情况下简化代码。
> 类方法是为了访问类属性更加方便。
> 参考：
> http://www.jianshu.com/p/212b6fdb2c50
> https://www.zhihu.com/question/20021164

------

###### D.私有化
> 默认情况下，属性在Python中都是“公开的”。很多OO语言给数据加上一些可见性，只提供访问函数来访问其值。这就是熟知的实现隐藏，是对象封装中的一个关键部分。
> * 双下划线
> Python为类元素（属性和方法）的私有性提供初步的形式。由双下划线开始的属性在运行时被“混淆”，所以直接访问是不允许的。实际上，这会在名字前面加上下划线和类名。
> 这种名字混淆的另一个目的,是为了保护变量不与父类名称空间相冲突。
> * 单下划线
> 简单的模块级私有化只需要在属性名前使用一个单下划线字符。防止模块的属性用"from modules import *"来加载。