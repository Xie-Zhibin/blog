# Thinking in C

> 为了更好地学习数据结构和算法，花了几天时间复习了一遍C语言。把原来没有理解透彻的和已经快要忘记的一些知识点记录下来，作为复习的总结，也方便以后参考。

***
## A.指针
> 指针是一个其数值为地址的变量(或数据对象)。指针是一种数据类型，可以进行相应的指针运算。
> 当创建一个指针时，系统只分配了用来存储指针本身的内存空间，并不分配用来存储数据的内存空间。因此在使用指针之前，必须给它赋予一个已分配的内存地址。未经初始化的指针由于其指向不确定，会带来很多潜在的错误。

***

## B.数组与指针
> 数组名同时也是该数组首元素的地址。即，```array == &array[0]```。
> 对于数组的访问可以由指向数组的指针代替， ```*(arr + i) == arr[i]```
> 对指针加1,不是使指针增加一个字节，而是等价于对指针的值加上它指向的对象的字节大小，即让指针指向下一个元素。

***

## C.函数与指针
> 使用指针作为函数的指针可以使函数操作各种复杂的数据结构。
> 指针也可以指向函数。一个函数指针可以作为另一个函数的参数。
> ```void (* pf)(char *);``` 表示pf是一个指向一个以字符指针为参数，无返回值的函数。```(* pf)```即为指向的函数。
> 在ANSI C中将两种调用指针指向的函数的方式视为等价，即```(* pf)() ```与 ```pf()```等价

***

## D.内存管理
> C中，可以用malloc() 和 free() 分别进行动态内存分配和释放内存。
> I.分配内存
> 在用malloc() 函数动态分配内存时，malloc()接受一个参数：所需内存字节数。然后malloc() 寻找可用内存中一个大小适合的块，分配成功，返回那块内存的第一个字节的地址，分配失败，返回NULL
> malloc()返回一个指向void的指针，这是ANSI C标准的一个新类型，这一类型被用作“通用指针”，因此一般需要把返回值指派为适当的类型。
> 如下代码请求30个double类型值的空间。
> ```
> double * ptd;
> ptd = (double *) malloc(30 * sizeof (double));
> ```
> 注：sizeof是一个运算符，不是一个函数。它的操作数可以时一个具体的数据对象(如一个变量名)，或者一个类型。如果是一个类型，操作数必须放在括号中。sizeof返回size_t类型的值，它是一个无符号整数类型，但不是一个新类型。C99中把%zd作为用来显示size_t类型值的printf()说明符，也可以使用%u, %lu代替.
>
> -----
>
> II.回收内存
> 由于C不具备如Java等其他语言的自动垃圾回收功能，适时释放分配的内存空间就变得及其重要，否则容易导致内存泄漏。
> 在编译程序时，静态变量的数量是固定的，在程序运行时也是不改变的。自动变量使用的内存数量在程序执行时自动增加或减少。但被分配的内存所使用的内存数量只会增加，除非记得使用free()

***
